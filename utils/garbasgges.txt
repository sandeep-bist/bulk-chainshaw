const axios = require("axios");
const TokenEncryption = require("../encr");
const TokenDecryption = require("../dcr");
const Tokenize=require("../utils/tokenize");
const Detokenize=require("../utils/detokenize");
const Datatokenize=require("../utils/dataTokenize");
const DataDetokenize=require("../utils/dataDetokenize");

const getAccessToken = require("./accessToken");

const chunk = (arr, chunkSize = 1, cache = []) => {
    const tmp = [...arr]
    if (chunkSize <= 0) return cache
    while (tmp.length) cache.push(tmp.splice(0, chunkSize))
    return cache
  }

class BatchProcessForTokenizing{
    async runAllQueries(pan_data,concurrentLimit,batchSize,action) {

        
        const batches = chunk(pan_data, batchSize);
        console.log("total batch tokenizing size: ",batches.length);
        let results = [];
        let final_result=[];
        results= await  this.callTasks(batches,concurrentLimit,action);
        // console.log("*****results===",results)
        console.log(results.length,"result")
        console.log("*****results===",(results))
        // if(results[0][0].hasOwnProperty("results")){
        for (let i=0;i<results.length;i++){
            // console.log("Outer Loop: ",i);
            for (let j=0;j<results[i].length;j++){
              // console.log("inner loop: ",j);
                    // for (let k=0;k<batchSize;k++){
                        final_result.push(...results[i][j].results.data)
                    // }
            }
        }
        return final_result;
        // }
        // else{
        //   throw new Error("Some error occured")
        // }

    }


  async  callTasks(batches,concurrentLimit,action) {
    var currentTask = 0;
    var final_results=[]
    while (currentTask<batches.length){

    async function createTaskInstance() {
      while (currentTask < batches.length) {
        if (action==="TOKENIZE"){
            return await Datatokenize.getEncryptedTokenData(
                batches[currentTask++]
              );
        }
        else{
            return await DataDetokenize.getDecryptedTokenData(
                batches[currentTask++]
              );
        }
         
        
      }
    }

    var tasks = [];
    for (let i = 0; i < concurrentLimit && currentTask< batches.length; i++) {
      tasks.push(createTaskInstance());
    }
    let result=await Promise.all(tasks);
    console.log("****Total hit counter****",final_results.length)

    final_results.push(result);

    // return Promise.all([...Array(concurrentLimit)].map(createTaskInstance));
    }

    return final_results
  }

  

}

module.exports = new BatchProcessForTokenizing();




import re

def check_string(s):
    # Check if the string starts and ends with an alphabet character
    start_end_alphabet = re.match(r'^[a-zA-Z].*[a-zA-Z]$', s) is not None

    # Check if the string contains only alphabets, underscores, and no spaces
    contains_valid_chars = re.match(r'^[a-zA-Z_]*$', s) is not None

    return start_end_alphabet and contains_valid_chars

# Example usage:
test_string = "abc_def"
result = check_string(test_string)

if result:
    print(f"The string '{test_string}' meets the criteria.")
else:
    print(f"The string '{test_string}' does not meet the criteria.")



    alias kns ="kubectl -n staging-mf"

 kubectl logs -f deploy/dev-mf-kyc-deployment --since 10m |grep -v health


kubectl get ns
raise exc
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/target/order/view/client_side_apis/mandate/mandate.py", line 238, in post
    if "error" in response["data"].json() and response.status_code == 422:
                                              ^^^^^^^^^^^^^^^^^^^^
AttributeError: 'dict' object has no attribute 'status_code'
[11/Jan/2024 07:40:12] "POST /order/v1/orders/create_mandate/ HTTP




INFO:info_log:Fetching the sip order in fintech api, user id 542 and data-[]
order form fechtch indstallment None
2024-01-11 11:16:54,253 log_level: ERROR file_name: create_order line_no: 925 process_id: 9 thread_id: 140080452716224 "Error occurred: string indices must be integers, not 'str'"
ERROR:info_log:Error occurred: string indices must be integers, not 'str'
[11/Jan/2024 11:16:54] "PATCH /order/v1/orders/create_order HTTP/1.1" 200 110






const axios = require("axios");
const TokenEncryption = require("../encr");
const TokenDecryption = require("../dcr");
const BatchProcessForTokenizing=require("../utils/batchProcess");

const TokenizeConfigs=require("../utils/config");


class Tokenize {


  async tokenize(data,concurrentLimit,batchSize) {
    TokenizeConfigs.initializeVariable(data);
    // console.log("data---------------", data);
    try {
      let isPanList =Array.isArray(data.pan);
      if (!isPanList){
        throw new Error("Pan Parameter takes List of PAN only");
      }
      if ((data.pan).length<1){
        throw new Error("Pan List Should not be empty");

      }
      let pan = data?.pan;
       let serverPublicKey = TokenizeConfigs?.serverPublicKey;
       let internalPrivateKey = TokenizeConfigs?.internalPrivateKey;
       let accessTokenUrl = TokenizeConfigs?.accessTokenUrl;
       let accessTokenPayload = TokenizeConfigs?.accessTokenPayload;
       let accessTokenAuth = TokenizeConfigs?.accessTokenAuth;
       let encryptedDataUrl = TokenizeConfigs?.encryptedDataUrl;
      let panTokenObj={};
      //   console.log("pan-----", !pan || pan === "");
      if (
        !pan ||
        pan === "" ||
        ! serverPublicKey ||
         serverPublicKey === "" ||
        ! internalPrivateKey ||
         internalPrivateKey === "" ||
        ! accessTokenUrl ||
         accessTokenUrl === "" ||
        ! accessTokenPayload ||
         accessTokenPayload === "" ||
        ! accessTokenAuth ||
         accessTokenAuth === "" ||
        ! encryptedDataUrl ||
         encryptedDataUrl === ""
      ) {
        // console.log("data");
        throw new Error("All field are required");
      }
      
      let encryptionFunction = TokenEncryption.encryption( serverPublicKey);
      // console.log("encryptionFunction---------------",encryptionFunction);

        // Encrypt each string using map() and the encryption function with the parameter
        let encryptionData = pan.map(encryptionFunction);

        console.log("Encryption Done Successfully");
        let flippedObject= Object.assign(...pan.map((k, i) =>({ [encryptionData[i]]:[k]})))
          // let flippedObject = Object.fromEntries(
          //   Object.entries(panTokenizeObj).map(([pan, token]) => [token, pan])
          // );
          // console.log("encryptionDatflippedObjecta---------------",flippedObject);

      // let encryptionData = TokenEncryption.encryption(pan, serverPublicKey);
      console.log("Calling Batch processing Function")
      let tokenizeData=await BatchProcessForTokenizing.runAllQueries(encryptionData,concurrentLimit,batchSize,"TOKENIZE")
      console.log("--------------Toekninzing server task complted--------------")
      // let tokenizeData = await  getEncryptedTokenData(
        // encryptedDataUrl,
        // accessTokenUrl,
        // accessTokenPayload,
        // accessTokenAuth,
      // );
      // let stringTokenObj={};
      if (encryptedDataUrl=="https://tokenizer.uat.data.nye.money/tokenize/api/v2/bulk-tokenize"){
      
      
        let encrpypted_token=tokenizeData;//.results.data
        let decryptionFunction = TokenDecryption.looperFunction( internalPrivateKey,flippedObject);
        
        // console.log("decryptionFunction---------------",decryptionFunction);
        // let decryptionToken = encrpypted_token.map(decryptionFunction);
        
        // var decryptionToken = encrpypted_token.reduce(decryptionFunction, {});
        var decryptionToken = encrpypted_token.forEach(decryptionFunction);
        
        console.log("--------Data Decrypted-------------")

        return flippedObject;
      }
      else if (encryptedDataUrl=="https://tokenizer.uat.data.nye.money/tokenize/api/v2.1/bulk-tokenize"){
      
      
        let encrpypted_token=tokenizeData;//.results.data
        let decryptionFunction = TokenDecryption.looperFunction( internalPrivateKey,flippedObject);
        
        // console.log("decryptionFunction---------------",decryptionFunction);
        // let decryptionToken = encrpypted_token.map(decryptionFunction);
        
        // var decryptionToken = encrpypted_token.reduce(decryptionFunction, {});
        var decryptionToken = encrpypted_token.forEach(decryptionFunction);
        
        console.log("--------Data Decrypted-------------")

        return flippedObject;
      }
      else{

      
        let encrpypted_token=tokenizeData;//.results.data
        // console.log("encrpypted_token---------------",encrpypted_token);
        
        let decryptionFunction = TokenDecryption.loopDecryption( internalPrivateKey,flippedObject);
        console.log("--------Data Decrypted-------------")
        // console.log("decryptionFunction---------------",decryptionFunction);
      // let decryptionToken = encrpypted_token.map(decryptionFunction);

      // var decryptionToken = encrpypted_token.reduce(decryptionFunction, {});
      var decryptionToken = encrpypted_token.forEach(decryptionFunction);
      // var decryptionToken = encrpypted_token.map(decryptionFunction);
        console.log("decryptionToken---------------");

      // let decryptionToken = TokenDecryption.decryption(
      //   tokenizeData.results.encryptedToken,
      //   internalPrivateKey
      // );
      console.log("--------final result return----------")
      return flippedObject;//{ tokenizePanList: decryptionToken };
      }
    } catch (e) {
      //   console.log("e--------------", e.message);
      return { error: e.message };
    }
  }

  // async getEncryptedTokenData(
  //   encryptionData
  // ) {
  //   let accessToken = await getAccessToken(
  //      accessTokenUrl,
  //      accessTokenPayload,
  //      accessTokenAuth
  //   );

  //   let data = {
  //     encryptedDataList: encryptionData,
  //   };
  //   let headers = {
  //     "Content-Type": "application/json",
  //     Authorization: `Bearer ${accessToken.access_token}`,
  //   };
  //   let res = await axios.post( encryptedDataUrl, data, { headers });
  //   return res.data;
  // }
}

module.exports = new Tokenize();
